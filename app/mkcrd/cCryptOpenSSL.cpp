/*
 *
 * Copyright (C) 2023 SuitableApp
 *
 * This file is part of Generate Credential File(mkcrd).
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
/**
 * @file cCryptOpenSSL.cpp
 * @brief Encode / decode strings using OpenSSL
 * @author S.Sasaki
 * @date 2017/01/10
 */
#include <iostream>
#include <memory>
#include <time.h>
#include <fstream>
#include <sstream>
#include <cstdio>
#include <cstring>
#include <map>
#include <cassert>
#include <stdlib.h>
#include <openssl/evp.h>
#include <openssl/sha.h>
#include <openssl/crypto.h>
#include <openssl/aes.h>
#include <openssl/rand.h>
#include "cCryptOpenSSL.h"


namespace ps
{
namespace app
{
namespace mkcrd
{

class cCryptOpenSSLImpl
{
public:
    typedef std::vector<BYTE> tByteVect;

    /**
     * @brief 
     *  Generate encryption key and initialize random number.
     * @param[in] sCtx
     *  Key generation character string.
     */
    cCryptOpenSSLImpl(const tstring& sCtx);

    /**
     * @brief 
     *  Perform release processing of OpenSSL.
     */
    ~cCryptOpenSSLImpl();

    /**
     * @brief 
     *  Encode the specified string in AES 256 bit, CFB mode
     * @param[in] sOrg Original string
     * @return Encoded string
     */
    tstring sEncryptStr(const tstring& sOrg);

    /**
     * @brief 
     *  Decode the specified string in AES 256 bit, CFB mode
     * @param[in] sOrg Encoded character string
     * @return Decoded character string
     */
    tstring sDecryptStr(const tstring& sOrg);
private:
    enum { NUM_BYTES_PER_CHAR = sizeof(tstring::value_type) / sizeof(tByteVect::value_type) };
    enum { NUM_BYTES_PER_CHAR_WIN = 2 };        ///< For Windows compatibility. Use it to handle Windows Unicode with UTF-8
    enum { BLOCK_SIZE_WIN = 16 };               ///< For Windows compatibility. Linux AES CFB mode has a block size of 1
    tstring sPassPhrase_;                       ///< Key string for generating shared key
    
    /**
     * @brief 
     *  For OpenSSL initialization<br/>
     *  Originally [key_] takes a hash of the key character string in SHA1 as a key,<br/>
     *  but since the key generated by OpenSSL and the key generated by WinCrypt did not match,<br/>
     *  the value of the key generated by WinCrypt is directly initialized.<br/>
     */
    EVP_CIPHER_CTX* ctx_;
    unsigned char iv_[EVP_MAX_IV_LENGTH];
    unsigned char key_[EVP_MAX_KEY_LENGTH] = {0xe4,0xc4,0x93,0x80,0x8b,0xdd,0xbb,0x89,0xb3,0xec,0xad,0xdb,0x1e,0x06,0x5e,0xfc,0x5e,0x11,0x11,0x70,0x72,0xa3,0x65,0x86,0x6d,0x31,0xd0,0x99,0x07,0x09,0x54,0xe8};

    /**
     * @brief 
     *  Generate a common key using the specified key character string using "SHA1"
     * @param[in] pPass Key string
     * @param[in] iPassSize Size of key string
     * @return 0:Success
     */
    int iGenerateKey(const unsigned char *pPass, int iPassSize);

    enum {KEYLENGTH_256 = 256 * 0x10000};       ///< Generate 256-bit AES key
    DWORD blkLen_;                              ///< Data amount per unit (unit: bit) for encryption
    DWORD iGetBlockSize() const                 ///< Block size (unit: bytes)
    {
        return BLOCK_SIZE_WIN;
    }
    
    /**
     * @brief 
     *  Returns the number rounded up of "a" in "b" unit. <br/>
     *  Enter "0" or more for "c".<br/>
     *  When "c == 0", an excessive number is returned by "b" which is greater than "a" and divisible by "b" at most.<br/>
     *  When "c == 1", the minimum number that is greater than "a" and divisible by "b" is returned.<br/>
     *  Can not specify "c> 1" (exclude by assert because unavailable value is returned)<br/>
     */
    template<typename LENGTH_TYPE>
    LENGTH_TYPE iCeil(const LENGTH_TYPE a, const LENGTH_TYPE b, const LENGTH_TYPE c)
    {
        assert(b > c);
        assert(c < 2);
#ifndef NDEBUG
        LENGTH_TYPE t=b;
        int n=0;
        for (int i=0; i < sizeof(LENGTH_TYPE)*8; ++i)
        {
            if (t & (LENGTH_TYPE) 1)
            {
                n++;
            }
            t >>= 1;
        }
        assert(n == 1);
#endif
        return (a + (b - c)) & ~(b - 1);
    }
};

/**
 * @details
 */
cCryptOpenSSLImpl::cCryptOpenSSLImpl(const tstring& sCtx)
    : sPassPhrase_ (sCtx), blkLen_(0)
{
    int iEncPassSize = sPassPhrase_.size()*NUM_BYTES_PER_CHAR_WIN;      // Size of generated key
    unsigned char cEncPass[iEncPassSize+1];                             // Generated key
    memset( cEncPass, 0, iEncPassSize+1 );
    
    /*
     * Windows compatibility processing.
     * Add one byte after each character for Unicode 1 character 2 byte compatibility.
     */
    for (size_t lp=0; lp<sPassPhrase_.size(); lp++)
    {
        cEncPass[lp*NUM_BYTES_PER_CHAR_WIN] = sPassPhrase_.c_str()[lp];
    }
#ifndef NDEBUG
    {
        for (int lp2=0; lp2<iEncPassSize; lp2++)
        {
            tcout << (int)cEncPass[lp2] << " ";
        }
        tcout << std::endl;
    }
#endif
    ctx_ = EVP_CIPHER_CTX_new();                                        // Initialization of OpenSSL
    EVP_CIPHER_CTX_init(ctx_);
    
    /*
     * Originally, key generation processing such as "SHA1" hash etc.
     * is performed, but since the key value is set directly, comment out the following.
     */
//              int keySize = EVP_BytesToKey(EVP_aes_256_cfb8(), EVP_sha1(), nullptr, cEncPass, iEncPassSize, 1, key_, iv_);
//              memset( &key_[20], 0, EVP_MAX_KEY_LENGTH-20 );  // For Windows compatibility, round the key to 20 bytes
//              iGenerateKey(cEncPass, iEncPassSize);
#ifndef NDEBUG
    {
        tcout << "hash key_:"  << ":";
        for (int lp2=0; lp2<EVP_MAX_KEY_LENGTH; lp2++)
        {
            tcout << (int)key_[lp2] << " ";
        }
        tcout << std::endl;
    }
    tcout << "EVP_MAX_IV_LENGTH:" << EVP_MAX_IV_LENGTH << std::endl;
#endif
    memset( iv_, 0xff, 16 );

    ::srand((unsigned) ::time(nullptr));                                    // Change of random number sequence
}

/**
 * @details
 */
cCryptOpenSSLImpl::~cCryptOpenSSLImpl()
{
    if (ctx_)
    {
        EVP_CIPHER_CTX_cleanup(ctx_);
        EVP_CIPHER_CTX_free(ctx_);
    }
}

/**
 * @details
 */
int cCryptOpenSSLImpl::iGenerateKey(const unsigned char *pPass, int iPassSize)
{    
    SHA_CTX sha1Ctx;
    unsigned char cHash[SHA_DIGEST_LENGTH+1];
    memset(cHash, 0, SHA_DIGEST_LENGTH+1);
    SHA1_Init(&sha1Ctx);
    SHA1_Update(&sha1Ctx, pPass, iPassSize);
    SHA1_Final(cHash, &sha1Ctx);
    memcpy(key_, cHash, SHA_DIGEST_LENGTH);

    return 0;
}

/**
 * @details
 */
tstring cCryptOpenSSLImpl::sEncryptStr(const tstring& sOrg)
{
    EVP_CipherInit_ex(ctx_, EVP_aes_256_cfb8(), nullptr, key_, iv_, 1);     // Initialized in CFB mode, AES 256 bit.
#ifndef NDEBUG
    tcout << "block:" << EVP_CIPHER_CTX_block_size(ctx_) << std::endl;
#endif
    blkLen_ = EVP_CIPHER_CTX_block_size(ctx_)*8;

    /*
     * Copy encrypted string to vector
     */
    DWORD iBlockSize = iGetBlockSize();
    const DWORD iNumChars = (DWORD) sOrg.size();
    const int iWidthNumChars = sizeof(iNumChars);
    
    /*
     * Prior to encryption, data is created so as to be arranged in the order of the number of characters,
     * padding, and connection string. Since padding is a byte sequence generated based on random numbers,
     * it corresponds to the first block in encryption,
     * so encrypted byte strings are agitated and convenient for obfuscation, so adopt this order did.
     */
    DWORD iBufSize = iWidthNumChars + NUM_BYTES_PER_CHAR_WIN * iNumChars;
    
    /*
     * The length of the buffer is rounded up to the block size and becomes iNewSize.
     */
    DWORD iNewSize = iCeil(iBufSize, iBlockSize, (DWORD) 0);
    DWORD iPadding = iNewSize - iBufSize;
    tByteVect::pointer pBytes = new BYTE[iNewSize];
    ::memset(pBytes, 0, iNewSize);
    ::memcpy(pBytes, &iNumChars, iWidthNumChars);
    if (sizeof(tstring::value_type) == 2)
    {
        /*
         * If 1 character 2 bytes, copy directly.
         */
        ::memcpy(pBytes + iWidthNumChars + iPadding, sOrg.c_str(), NUM_BYTES_PER_CHAR * iNumChars);
    }
    else
    {
        /*
         * Windows compatibility processing.
         * Add one byte after each character for Unicode 1 character 2 byte compatibility.
         */
        for (size_t lp=0; lp<sOrg.size(); lp++)
        {
            pBytes[iWidthNumChars + iPadding + lp * NUM_BYTES_PER_CHAR_WIN] = sOrg[lp];
        }
    }
#ifndef NDEBUG
    tcout << "tstring:" << sizeof(tstring::value_type) << std::endl;
    tcout << "tByteVect:" << sizeof(tByteVect::value_type) << std::endl;
    tcout << "iBlockSize:" << iBlockSize << std::endl;
    tcout << "iNumChars:" << iNumChars << std::endl;
    tcout << "iWidthNumChars:" << iWidthNumChars << std::endl;
    tcout << "iBufSize:" << iBufSize << std::endl;
    tcout << "iNewSize:" << iNewSize << std::endl;
    tcout << "iPadding:" << iPadding << std::endl;
    tcout << "pBytes:" << pBytes << std::endl;
#endif

    /*
     * Padding an unused portion ahead of the connection character string with a randomly generated byte string.
     * It aims to ensure that the encrypted result string is appropriately scattered.
     */
    for (DWORD i = iWidthNumChars; i < iWidthNumChars + iPadding; ++i)
    {
        pBytes[i] = (BYTE)(rand() % 0x100);
    }
    tByteVect oBlob(&pBytes[0], &pBytes[iNewSize]);
    delete [] pBytes;

#ifndef NDEBUG
    tcout << "oBlob.size:" << oBlob.size() << std::endl;
    {
        for (tByteVect::const_iterator it = oBlob.begin(), ite = oBlob.end(); it != ite; ++it)
        {
            tcout << (int)*it << TCHAR(' ');
            
            /*
             * Add carrige return / line feed.
             */
            if (((it - oBlob.begin()) % iBlockSize) == (iBlockSize - 1))
            {
                tcout << std::endl;
            }
        }
    }
#endif

    tByteVect oEncrypted;
    tByteVect oEncryptedTmp;
    oEncryptedTmp.resize(iBlockSize * 2);

    /*
     * Note that blocked ciphers will replace the iMod value with the block size.
     */
    DWORD iDiv = (DWORD) oBlob.size() * sizeof(tByteVect::value_type) / iBlockSize;
    DWORD iMod =         oBlob.size() * sizeof(tByteVect::value_type) % iBlockSize;
#ifndef NDEBUG
    tcout << "iDiv:" << iDiv << std::endl;
    tcout << "iMod:" << iMod << std::endl;
#endif

    /*
     * Padding the short enough to be divisible by the block size.
     */
    LPBYTE pPtr;
    int iActualSize = 0;
    int iFinalSize;
    for (DWORD j = 0; j < iDiv; ++j)
    {
#ifndef NDEBUG
        tcout << "convert cnt:" << j << std::endl;
#endif
        pPtr = (LPBYTE) oBlob.data() + (j * iBlockSize);
        EVP_CipherUpdate(ctx_, &oEncryptedTmp[0], &iActualSize, pPtr, iBlockSize);
#ifndef NDEBUG
        tcout << "iActualSize:" << iActualSize << std::endl;
#endif
        EVP_CipherFinal_ex(ctx_, &oEncryptedTmp[iActualSize], &iFinalSize);
        oEncryptedTmp.resize( iActualSize );
        oEncrypted.insert( oEncrypted.end(), oEncryptedTmp.begin(), oEncryptedTmp.end() );
    }
    if (iMod)
    {
        pPtr = (LPBYTE) oBlob.data() + (iDiv * iBlockSize);
        EVP_CipherUpdate(ctx_, &oEncryptedTmp[0], &iActualSize, pPtr, iMod);
        EVP_CipherFinal_ex(ctx_, &oEncryptedTmp[iActualSize], &iFinalSize);
        oEncryptedTmp.resize( iActualSize );
        oEncrypted.insert( oEncrypted.end(), oEncryptedTmp.begin(), oEncryptedTmp.end() );
    }

    /*
     * Writing encrypted character string to string stream: Represent in hexadecimal number.
     */
    tostringstream oTos;
    oTos.flags( std::ios_base::hex | std::ios_base::left);
    for (tByteVect::const_iterator it = oEncrypted.begin(), ite = oEncrypted.end(); it != ite; ++it)
    {
        oTos << (int)*it << TCHAR(' ');
        
        /**
         * Add carrige return / line feed.
         */
        if (((it - oEncrypted.begin()) % iBlockSize) == (iBlockSize - 1))
        {
            oTos << std::endl;
        }
    }
    return oTos.str();
}

/**
 * @details
 */
tstring cCryptOpenSSLImpl::sDecryptStr(const tstring& sOrg)
{
    EVP_CipherInit_ex(ctx_, EVP_aes_256_cfb8(), nullptr, key_, iv_, 0);
    blkLen_ = EVP_CIPHER_CTX_block_size(ctx_)*8;
    DWORD iBlockSize = iGetBlockSize();

    tByteVect oBlob;        // Data conversion vector for encryption / decryption
    
    /*
     * Writing encrypted character string to string stream: Represent in hexadecimal number.
     */
    tistringstream oTis(sOrg);
    WORD cBy;
    while (oTis >> std::noshowbase >> std::hex >> cBy)
    {
        oBlob.push_back((BYTE) cBy);
    }
#ifndef NDEBUG
    {
        for (tByteVect::const_iterator it = oBlob.begin(), ite = oBlob.end(); it != ite; ++it)
        {
            tcout << (int)*it << TCHAR(' ');
        }
        tcout << std::endl;
    }
#endif

    tByteVect oDencrypted;
    tByteVect oDencryptedTmp;
    oDencryptedTmp.resize(oBlob.size()*2);

#ifndef NDEBUG
    tcout << "oBlob.size:" << oBlob.size() << std::endl;
#endif

    /*
     * Decrypt
     * Note that blocked ciphers will replace the iMod value with the block size.
     */
    DWORD iDiv = (DWORD) oBlob.size() * sizeof(tByteVect::value_type) / iBlockSize;
    DWORD iMod =         oBlob.size() * sizeof(tByteVect::value_type) % iBlockSize;
#ifndef NDEBUG
    tcout << "iDiv:" << iDiv << std::endl;
    tcout << "iMod:" << iMod << std::endl;
#endif

    /*
     * Decrypt by block size unit.
     */
    LPBYTE pPtr;
    int iActualSize = 0;
    int iFinalSize;
    DWORD iDivCnt = 0;
    while(1)
    {
        pPtr = (LPBYTE) oBlob.data() + (iDivCnt * iBlockSize);
        EVP_CipherUpdate(ctx_, &oDencryptedTmp[0], &iActualSize, pPtr, iBlockSize);
        EVP_CipherFinal_ex(ctx_, &oDencryptedTmp[iActualSize], &iFinalSize);
#ifndef NDEBUG
        tcout << "iActualSize:" << iActualSize << std::endl;
#endif
        if (iActualSize)
        {
            oDencryptedTmp.resize( iActualSize );
            oDencrypted.insert( oDencrypted.end(), oDencryptedTmp.begin(), oDencryptedTmp.end() );
            iDivCnt++;
            iActualSize = 0;
            oDencryptedTmp.clear();
            oDencryptedTmp.resize(oBlob.size()*2);
        }
        if (iDivCnt >= iDiv)
        {
            break;
        }
    }
    if (iMod)
    {
        pPtr = (LPBYTE) oBlob.data() + (iDiv * iBlockSize);
        EVP_CipherUpdate(ctx_, &oDencryptedTmp[0], &iActualSize, pPtr, iMod);
        EVP_CipherFinal_ex(ctx_, &oDencryptedTmp[iActualSize], &iFinalSize);
        oDencryptedTmp.resize( iActualSize );
        oDencrypted.insert( oDencrypted.end(), oDencryptedTmp.begin(), oDencryptedTmp.end() );
    }

#ifndef NDEBUG
    {
        for (tByteVect::const_iterator it = oDencrypted.begin(), ite = oDencrypted.end(); it != ite; ++it)
        {
            tcout << (int)*it << TCHAR(' ');
        }
        tcout << std::endl;
    }
#endif

    DWORD iNumChars;
    ::memcpy(&iNumChars, oDencrypted.data(), sizeof(iNumChars));
#ifndef NDEBUG
    tcout << "iNumChars:" << iNumChars << std::endl;
#endif
    tstring::pointer pChars = new TCHAR[iNumChars*NUM_BYTES_PER_CHAR_WIN];
    
    /*
     * Since the restored character string is one byte two bytes, delete extra bytes.
     */
    for (DWORD lp=0; lp<iNumChars; lp++)
    {
        pChars[lp] = (oDencrypted.data() + (oDencrypted.size() - NUM_BYTES_PER_CHAR_WIN * iNumChars))[lp*NUM_BYTES_PER_CHAR_WIN];
    }
    tstring sRet(&pChars[0], iNumChars);
    delete [] pChars;
    return sRet;
}

/**
 * @details
 */
cCryptOpenSSL::cCryptOpenSSL(const tstring& sCtx) : Impl(new cCryptOpenSSLImpl(sCtx))
{}

/**
 * @details
 */
cCryptOpenSSL::~cCryptOpenSSL()
{}

/**
 * @details
 */
tstring cCryptOpenSSL::sEncryptStr(const tstring& sOrg)
{
    return Impl->sEncryptStr(sOrg);
}

/**
 * @details
 */
tstring cCryptOpenSSL::sDecryptStr(const tstring& sOrg)
{
    return Impl->sDecryptStr(sOrg);
}
} // ps::app::mkcrd
} // ps::app
} // ps
