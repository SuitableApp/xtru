/*
 *
 * Copyright (C) 2023 SuitableApp
 *
 * This file is part of Extreme Unloader(XTRU).
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include <pslib.h>

namespace ps
{
namespace lib
{
namespace nsStreamLocator
{

class cStreamLocatorImpl
{
public:
    cStreamLocatorImpl(
        const std::string& sOwner
        , const std::string& sTableName
        , const std::string& sPartitionName
    );
    std::ostream* oOpen(const tExtType& iExtType, const std::string& sDataFileDir);
    const boost::filesystem::path& oGetsLastOpendFilename() const;
    const std::string sGetPartitionName() const;
private:
    /**
     * @class Token
     * @brief
     * An abstract class representing a token.
     */
    class Token
    {
    public:
        /**
         * @brief
         *   Returns a string generated by applying the contents of the parameter.
         * @return
         *   Generated string.
         */
        virtual std::string operator()(const tInitParams&, const tExtType&, const std::string&) const = 0;
        /// @brief Default destructor.
        virtual ~Token() = default;
    };
    /**
     * @class LiteralToken
     * @brief
     * A token representing a literal string.
     */
    class LiteralToken
        : public cStreamLocatorImpl::Token
    {
    public:
        /**
         * @brief
         * Construct an instance of this class.
         * @param[in] s
         *   Literal string.
         */
        explicit LiteralToken(const std::string& s)
            : s_(s)
        {}
        /// @brief @copydoc Token::sGetSymVal()
        std::string operator()(const tInitParams&, const tExtType&, const std::string&) const
        {
            return s_;
        }
    private:
        std::string s_;
    };
    /**
     * @class VariableToken
     * @brief
     * A token representing a variable string ( macro symbol ).
     */
    class VariableToken
        : public cStreamLocatorImpl::Token
    {
    public:
        /**
         * @brief
         * Construct an instance of this class.
         * @param[in] macro
         * @param[in] option
         */
        VariableToken(const std::string& macro, const std::string& option)
            : sMacro_(macro), sOption_(option)
        {}
        /// @brief @copydoc Token::sGetSymVal()
        std::string operator()(const tInitParams& params, const tExtType& iExtType, const std::string& sDataFileDir) const
        {
            return oMacroMap_.at(sMacro_)(params, sOption_, iExtType, sDataFileDir);
        }
    private:
        const std::string sMacro_;
        const std::string sOption_;
    };
    /// @brief Object for trace output.
    ps::lib::cTracer& trc_;
    /// @brief @copybrief tInitParams
    tInitParams rInitParams_;
    boost::filesystem::path sLastOpendFilenme_;
};

cStreamLocatorImpl::cStreamLocatorImpl(
    const std::string& sOwner
    , const std::string& sTableName
    , const std::string& sPartitionName
)
    : trc_(ps::lib::cTracer::get_mutable_instance())
    , rInitParams_({sOwner, sTableName, sPartitionName})
{}

std::ostream* cStreamLocatorImpl::oOpen(const tExtType& iExtType, const std::string& sDataFileDir)
{
    ASSERT_OR_RAISE(iHasBeenInitialized()
        , std::runtime_error
        , "vInitialize() must be previously called.");
    /*
     * Selection of scheme.
     */
    boost::smatch m;
    boost::regex_match(sGetStreamLocator(iExtType), m, regLocationExpr);
    const auto& scheme = m["scheme"].str();
    // A generator is choosen here. But std::ostream is not instantiated.
    const auto& itSelectedGenerator = oSchemeMap_.find(scheme);
    ASSERT_OR_RAISE(itSelectedGenerator != oSchemeMap_.end(), std::runtime_error
        , boost::format("The specified scheme name %s is not supported") % scheme);
    const auto& location = m["location"].str();
    trc_ << boost::format("scheme=%s, location=%s") % scheme % location << std::endl;
    /*
     * Parsing of the macros embedded in the location.
     */
    boost::sregex_iterator it1(
        location.begin(), location.end(), regMacroSymbolExpr
    ); // current of matching.
    boost::sregex_iterator it2; // end of matching.
    auto lastPos = 0lu;
    /**
     * @brief
     * Holds the tokens obtained by analyzing the output location string.
     */
    boost::ptr_vector<Token> tokens_;
    for (; it1 != it2; it1++)
    {
        const size_t pos = it1->position();
        const auto length = it1->length();
        if (pos != lastPos)
        {
            /* regMacroSymbolExpr un-matched fragment. */
            tokens_.push_back(
                new LiteralToken(location.substr(lastPos, pos - lastPos)));
        }
        try
        {
            /* regMacroSymbolExpr matched fragment. */
            tokens_.push_back(
                new VariableToken((*it1)["var"], (*it1)["opt"]));
        }
        catch (std::out_of_range&)
        {
            tokens_.push_back(
                new LiteralToken(location.substr(pos, length)));
        }
        lastPos = pos + length;
    }
    /* last regMacroSymbolExpr un-matched fragment. */
    if (location.length() > lastPos)
    {
        tokens_.push_back(
            new LiteralToken(location.substr(lastPos)));
    }
    std::stringstream ss;
    for (auto& token : tokens_)
    {
        ss << token(rInitParams_, iExtType, sDataFileDir);
    }
    // generates a kind of std::ostream.
    sLastOpendFilenme_ = ss.str();
    return itSelectedGenerator->second(sLastOpendFilenme_.string());
}

const boost::filesystem::path& cStreamLocatorImpl::oGetsLastOpendFilename() const
{
    BOOST_ASSERT(sLastOpendFilenme_.has_filename());
    return sLastOpendFilenme_;
}

const std::string cStreamLocatorImpl::sGetPartitionName() const
{
    return rInitParams_.sPartitionName;
}

/**
 * works to mediate between the interface and the implementation.
 */
cStreamLocator::cStreamLocator(
    const std::string& sOwner
    , const std::string& sTableName
    , const std::string& sPartitionName
)
    : oImpl_(
        new cStreamLocatorImpl(sOwner, sTableName, sPartitionName)
        , vRegularDeleter<cStreamLocatorImpl>
    )
{}

cStreamLocator::~cStreamLocator()
{}

std::unique_ptr<std::ostream> cStreamLocator::oOpen(const tExtType& iExtType, const std::string& sDataFileDir)
{
    return std::unique_ptr<std::ostream>(oImpl_->oOpen(iExtType, sDataFileDir));
}

const boost::filesystem::path& cStreamLocator::oGetsLastOpendFilename() const
{
    return oImpl_->oGetsLastOpendFilename();
}

const std::string cStreamLocator::sGetPartitionName() const
{
    return oImpl_->sGetPartitionName();
}

} // ps::lib::nsStreamLocator

} // ps::lib

} // ps
